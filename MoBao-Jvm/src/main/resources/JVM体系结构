
负责运行一个java程序。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，
这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。
每个Java程序都运行于它自己的Java虚拟机实例中。

(1)每个Java虚拟机实例都有一个方法区以及一个堆，它们是由该虚拟机实例中所有的线程共享的.
当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息。
然后把这些类型信息放到方法区中。当程序运行时，虚拟机会把所有该程序在运行时创建的对象都放到堆中。

(2)当每一个新线程被创建时，它都将得到它自己的PC寄存器（程序计数器）以及一个Java栈
如果线程正在执行的是一个Java方法（非本地方法），那么PC寄存器的值将总是指向下一条将被执行的指令，
而它的Java栈则总是存储该线程中Java方法调用的状态——包括它的局部变量，被调用时传进来的参数、返回值，
以及运算的中间结果等等。
而本地方法调用的状态，则是以某种依赖于具体实现的方法存储在本地方法栈中，
也可能是在寄存器或者其他某些与特定实现相关的内存区中。

类装载子系统
在JAVA虚拟机中，负责查找并装载类型的那部分被称为类装载子系统。

方法区
在Java虚拟机中，关于被装载类型的信息存储在一个逻辑上被称为方法区的内存中
当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件

当虚拟机运行Java程序时，它会查找使用存储在方法区中的类型信息。由于所有线程都共享方法区，
因此它们对方法区数据的访问必须被设计为是线程安全的。比如，假设同时有两个线程都企图访问一个名为Lava的类，
而这个类还没有被装入虚拟机，那么，这时只应该有一个线程去装载它，而另一个线程则只能等待

对于每个装载的类型，虚拟机都会在方法区中存储以下类型信息：

这个类型的全限定名
　　●　这个类型的直接超类的全限定名（除非这个类型是java.lang.Object，它没有超类）
　　●　这个类型是类类型还是接口类型
　　●　这个类型的访问修饰符（public、abstract或final的某个子集）
　　●　任何直接超接口的全限定名的有序列表
该类型的常量池
字段信息
方法信息
除了常量以外的所有类（静态）变量
一个到类ClassLoader的引用
一个到Class类的引用

http://www.jianshu.com/p/40d4c7aebd66




http://itindex.net/detail/50346-jvm-%E6%96%B0%E7%94%9F%E4%BB%A3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6

http://itindex.net/detail/19269-jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6







